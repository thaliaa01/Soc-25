# -*- coding: utf-8 -*-
"""crowdfunding-

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LHqPjJKLf1pHWblvgILX_Cfbou6I_P-Z
"""

!pip install web3 py-solc-x eth-tester==0.9.0b1 py-evm==0.7.0a2
!pip install web3 py-solc-x

from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc


w3 = Web3(EthereumTesterProvider())


print(f"Connected: {w3.is_connected()}")
print(f"Test accounts: {w3.eth.accounts}")


install_solc('0.8.0')

hello_world_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract HelloWorld {
    string public greeting;

    constructor() {
        greeting = "Hello, World!";
    }

    function setGreeting(string memory _greeting) public {
        greeting = _greeting;
    }

    function getGreeting() public view returns (string memory) {
        return greeting;
    }
}
"""


compiled = compile_source(hello_world_code, solc_version='0.8.0')
contract_id, contract_interface = compiled.popitem()


account = w3.eth.accounts[0]

HelloWorld = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = HelloWorld.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)


hello = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])


print("Initial greeting:", hello.functions.getGreeting().call())


hello.functions.setGreeting("Hello from Google Colab!").transact({'from': account})
print("Updated greeting:", hello.functions.getGreeting().call())

!pip install web3 py-solc-x eth-tester==0.9.0b1 py-evm==0.7.0a2

from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc

w3 = Web3(EthereumTesterProvider())
print("Connected:", w3.is_connected())


install_solc('0.8.20')


crowdfunding_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

error NotOwner();
error CampaignClosed();
error DeadlinePassed();
error GoalNotMet();
error AlreadyWithdrawn();
error NoContribution();

struct Campaign {
    address owner;
    string title;
    uint goal;
    uint deadline;
    uint fundsRaised;
    bool isOpen;
    mapping(address => uint) contributions;
}

contract Crowdfunding {
    uint public campaignCount;
    mapping(uint => Campaign) private campaigns;

    event CampaignCreated(uint indexed campaignId, address indexed owner, string title, uint goal, uint deadline);
    event ContributionReceived(uint indexed campaignId, address indexed contributor, uint amount);
    event FundsWithdrawn(uint indexed campaignId, uint amount);
    event Refunded(uint indexed campaignId, address indexed contributor, uint amount);

    modifier onlyOwner(uint _campaignId) {
        if (msg.sender != campaigns[_campaignId].owner) revert NotOwner();
        _;
    }

    modifier campaignExists(uint _campaignId) {
        require(_campaignId < campaignCount, "Campaign does not exist");
        _;
    }

    constructor() {}

    function createCampaign(string memory _title, uint _goal, uint _durationInSeconds) public {
        uint id = campaignCount;

        Campaign storage campaign = campaigns[id];
        campaign.owner = msg.sender;
        campaign.title = _title;
        campaign.goal = _goal;
        campaign.deadline = block.timestamp + _durationInSeconds;
        campaign.isOpen = true;

        emit CampaignCreated(id, msg.sender, _title, _goal, campaign.deadline);
        campaignCount++;
    }

    function contribute(uint _campaignId) public payable campaignExists(_campaignId) {
        Campaign storage campaign = campaigns[_campaignId];
        if (!campaign.isOpen) revert CampaignClosed();
        if (block.timestamp > campaign.deadline) revert DeadlinePassed();
        require(msg.value > 0, "Must send ETH");

        campaign.fundsRaised += msg.value;
        campaign.contributions[msg.sender] += msg.value;

        emit ContributionReceived(_campaignId, msg.sender, msg.value);
    }

    function withdrawFunds(uint _campaignId) public campaignExists(_campaignId) onlyOwner(_campaignId) {
        Campaign storage campaign = campaigns[_campaignId];
        if (!campaign.isOpen) revert AlreadyWithdrawn();
        if (campaign.fundsRaised < campaign.goal) revert GoalNotMet();

        campaign.isOpen = false;
        uint amount = campaign.fundsRaised;
        campaign.fundsRaised = 0;

        payable(campaign.owner).transfer(amount);
        emit FundsWithdrawn(_campaignId, amount);
    }

    function refund(uint _campaignId) public campaignExists(_campaignId) {
        Campaign storage campaign = campaigns[_campaignId];
        if (block.timestamp <= campaign.deadline) revert DeadlinePassed();
        if (campaign.fundsRaised >= campaign.goal) revert GoalNotMet();

        uint amount = campaign.contributions[msg.sender];
        if (amount == 0) revert NoContribution();

        campaign.contributions[msg.sender] = 0;
        payable(msg.sender).transfer(amount);

        emit Refunded(_campaignId, msg.sender, amount);
    }
}
"""

compiled = compile_source(crowdfunding_code, solc_version='0.8.20')
contract_id, contract_interface = compiled.popitem()


account = w3.eth.accounts[0]


Crowdfunding = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = Crowdfunding.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
contract = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])

print("Crowdfunding Contract Deployed At:", tx_receipt.contractAddress)

# WEEK 2
tx = contract.functions.createCampaign("Shreya's Project", 1000, 10000).transact({'from': account})
w3.eth.wait_for_transaction_receipt(tx)
print("Campaign created")

# WEEK 3
contributor = w3.eth.accounts[1]
tx = contract.functions.contribute(0).transact({'from': contributor, 'value': 500})
w3.eth.wait_for_transaction_receipt(tx)
print("Contribution done")

# WEEK 4
try:
    contract.functions.withdrawFunds(0).transact({'from': account})
except Exception as e:
    print("Withdraw failed (goal not met):", str(e))


tx = contract.functions.contribute(0).transact({'from': contributor, 'value': 600})
w3.eth.wait_for_transaction_receipt(tx)

tx = contract.functions.withdrawFunds(0).transact({'from': account})
w3.eth.wait_for_transaction_receipt(tx)
print("Withdraw successful (goal met)")

