# -*- coding: utf-8 -*-
"""soc_crowdfunding

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uk12FTwz7QhbhtsPT6HqfT9Fok5NcbBF
"""

# Week 1: Install dependencies (Run this in a Colab cell)
!pip install web3 py-solc-x eth-tester==0.9.0b1 py-evm==0.7.0a2

# Week 1: Import modules
from web3 import Web3, EthereumTesterProvider
from solcx import compile_source, install_solc
import time

# Week 1: Connect to Ethereum tester
w3 = Web3(EthereumTesterProvider())
account = w3.eth.accounts[0]
contributor = w3.eth.accounts[1]

# Week 1: Install and set compiler
install_solc('0.8.0')

# Week 1-4: Solidity contract for Crowdfunding
crowdfunding_code = """
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Crowdfunding {
    struct Campaign {
        address payable owner;
        string title;
        uint goal;
        uint deadline;
        uint raised;
        bool withdrawn;
        mapping(address => uint) contributions;
    }

    uint public campaignCount;
    mapping(uint => Campaign) public campaigns;

    event CampaignCreated(uint id, address indexed owner, string title, uint goal, uint deadline);
    event Contributed(uint indexed id, address indexed contributor, uint amount);
    event FundsWithdrawn(uint indexed id, uint amount);
    event Refunded(uint indexed id, address indexed contributor, uint amount);

    bool internal locked;
    modifier noReentrant() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }

    function createCampaign(string memory _title, uint _goal, uint _duration) public {
        require(_goal > 0, "Goal must be > 0");
        require(_duration > 0, "Duration must be > 0");

        Campaign storage c = campaigns[campaignCount];
        c.owner = payable(msg.sender);
        c.title = _title;
        c.goal = _goal;
        c.deadline = block.timestamp + _duration;
        c.raised = 0;
        c.withdrawn = false;

        emit CampaignCreated(campaignCount, msg.sender, _title, _goal, c.deadline);
        campaignCount++;
    }

    function contribute(uint _id) public payable {
        Campaign storage c = campaigns[_id];
        require(block.timestamp < c.deadline, "Deadline passed");
        require(msg.value > 0, "Must send Ether");

        c.contributions[msg.sender] += msg.value;
        c.raised += msg.value;

        emit Contributed(_id, msg.sender, msg.value);
    }

    function withdrawFunds(uint _id) public noReentrant {
        Campaign storage c = campaigns[_id];
        require(msg.sender == c.owner, "Only owner can withdraw");
        require(block.timestamp >= c.deadline, "Deadline not reached");
        require(c.raised >= c.goal, "Goal not met");
        require(!c.withdrawn, "Already withdrawn");

        c.withdrawn = true;
        c.owner.transfer(c.raised);

        emit FundsWithdrawn(_id, c.raised);
    }

    function refund(uint _id) public noReentrant {
        Campaign storage c = campaigns[_id];
        require(block.timestamp >= c.deadline, "Deadline not reached");
        require(c.raised < c.goal, "Goal was met");

        uint amount = c.contributions[msg.sender];
        require(amount > 0, "Nothing to refund");

        c.contributions[msg.sender] = 0;
        payable(msg.sender).transfer(amount);

        emit Refunded(_id, msg.sender, amount);
    }

    function getCampaign(uint _id) public view returns (
        address owner,
        string memory title,
        uint goal,
        uint deadline,
        uint raised,
        bool withdrawn
    ) {
        Campaign storage c = campaigns[_id];
        return (c.owner, c.title, c.goal, c.deadline, c.raised, c.withdrawn);
    }

    function getContribution(uint _id, address _addr) public view returns (uint) {
        return campaigns[_id].contributions[_addr];
    }
}
"""

# Week 1: Compile and deploy the contract
compiled = compile_source(crowdfunding_code, solc_version='0.8.0')
_, contract_interface = compiled.popitem()

Crowdfunding = w3.eth.contract(abi=contract_interface['abi'], bytecode=contract_interface['bin'])
tx_hash = Crowdfunding.constructor().transact({'from': account})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
contract = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_interface['abi'])

print("Contract deployed at:", contract.address)

# Week 2: Create a campaign
tx = contract.functions.createCampaign("Shreya's Campaign", 1000, 10).transact({'from': account})
w3.eth.wait_for_transaction_receipt(tx)
print("Campaign created")

# Week 3: Contribute to the campaign
contributor = w3.eth.accounts[1]
tx = contract.functions.contribute(0).transact({'from': contributor, 'value': 500})
w3.eth.wait_for_transaction_receipt(tx)
print("First contribution done")

# Wait for deadline to expire
print("Waiting for campaign deadline to pass...")
time.sleep(12)

# Week 4: Try refund (goal not met)
tx = contract.functions.refund(0).transact({'from': contributor})
w3.eth.wait_for_transaction_receipt(tx)
print("Refund done")

# Week 6: Read campaign details
print("Campaign:", contract.functions.getCampaign(0).call())
print("Contribution:", contract.functions.getContribution(0, contributor).call())

